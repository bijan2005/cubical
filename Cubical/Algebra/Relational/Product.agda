{-

Product of Algebra S and T: X ??? S X ?? T X

-}
{-# OPTIONS --cubical --no-import-sorts --safe #-}
module Cubical.Algebra.Relational.Product where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Function
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Structure
open import Cubical.Foundations.RelationalStructure
open import Cubical.Foundations.SIP
open import Cubical.Foundations.Univalence
open import Cubical.Data.Sigma
open import Cubical.HITs.PropositionalTruncation as Trunc
open import Cubical.HITs.SetQuotients

open import Cubical.Algebra.Product

private
  variable
    ??? ?????? ??????' ??????'' ?????? ??????' ??????'' : Level

-- Structured relations

ProductRelStr :
  {S??? : Type ??? ??? Type ??????} (????? : StrRel S??? ??????')
  {S??? : Type ??? ??? Type ??????} (????? : StrRel S??? ??????')
  ??? StrRel (ProductStructure S??? S???) (???-max ??????' ??????')
ProductRelStr ????? ????? R (s??? , s???) (t??? , t???) =
  ????? R s??? t??? ?? ????? R s??? t???

productSuitableRel :
  {S??? : Type ??? ??? Type ??????} {????? : StrRel S??? ??????'}
  {S??? : Type ??? ??? Type ??????} {????? : StrRel S??? ??????'}
  ??? SuitableStrRel S??? ????? ??? SuitableStrRel S??? ?????
  ??? SuitableStrRel (ProductStructure S??? S???) (ProductRelStr ????? ?????)
productSuitableRel ????? ????? .quo (X , s??? , s???) R (r??? , r???) .fst .fst =
  ????? .quo (X , s???) R r??? .fst .fst , ????? .quo (X , s???) R r??? .fst .fst
productSuitableRel ????? ????? .quo (X , s??? , s???) R (r??? , r???) .fst .snd =
  ????? .quo (X , s???) R r??? .fst .snd , ????? .quo (X , s???) R r??? .fst .snd
productSuitableRel ????? ????? .quo (X , s??? , s???) R (r??? , r???) .snd ((q??? , q???) , (c??? , c???)) i .fst =
  ????? .quo (X , s???) R r??? .snd (q??? , c???) i .fst , ????? .quo (X , s???) R r??? .snd (q??? , c???) i .fst
productSuitableRel ????? ????? .quo (X , s??? , s???) R (r??? , r???) .snd ((q??? , q???) , (c??? , c???)) i .snd =
  ????? .quo (X , s???) R r??? .snd (q??? , c???) i .snd , ????? .quo (X , s???) R r??? .snd (q??? , c???) i .snd
productSuitableRel ????? ????? .symmetric R (r??? , r???) =
  ????? .symmetric R r??? , ????? .symmetric R r???
productSuitableRel ????? ????? .transitive R R' (r??? , r???) (r???' , r???') =
  ????? .transitive R R' r??? r???' , ????? .transitive R R' r??? r???'
productSuitableRel ????? ????? .set setX =
  isSet?? (????? .set setX) (????? .set setX)
productSuitableRel ????? ????? .prop propR (s??? , s???) (t??? , t???) =
  isProp?? (????? .prop propR s??? t???) (????? .prop propR s??? t???)

productRelMatchesEquiv :
  {S??? : Type ??? ??? Type ??????} (????? : StrRel S??? ??????') {????? : StrEquiv S??? ??????''}
  {S??? : Type ??? ??? Type ??????} (????? : StrRel S??? ??????') {????? : StrEquiv S??? ??????''}
  ??? StrRelMatchesEquiv ????? ????? ??? StrRelMatchesEquiv ????? ?????
  ??? StrRelMatchesEquiv (ProductRelStr ????? ?????) (ProductEquivStr ????? ?????)
productRelMatchesEquiv ????? ????? ????? ????? A B e =
  ??-cong-equiv (????? _ _ e) (?? _ ??? ????? _ _ e)

productRelAction :
  {S??? : Type ??? ??? Type ??????} {????? : StrRel S??? ??????'} (????? : StrRelAction ?????)
  {S??? : Type ??? ??? Type ??????} {????? : StrRel S??? ??????'} (????? : StrRelAction ?????)
  ??? StrRelAction (ProductRelStr ????? ?????)
productRelAction ????? ????? .actStr f (s??? , s???) = ????? .actStr f s??? , ????? .actStr f s???
productRelAction ????? ????? .actStrId (s??? , s???) = ??PathP (????? .actStrId s??? , ????? .actStrId s???)
productRelAction ????? ????? .actRel h _ _ (r??? , r???) = ????? .actRel h _ _ r??? , ????? .actRel h _ _ r???

productPositiveRel :
  {S??? : Type ??? ??? Type ??????} {????? : StrRel S??? ??????'} {????? : SuitableStrRel S??? ?????}
  {S??? : Type ??? ??? Type ??????} {????? : StrRel S??? ??????'} {????? : SuitableStrRel S??? ?????}
  ??? PositiveStrRel ?????
  ??? PositiveStrRel ?????
  ??? PositiveStrRel (productSuitableRel ????? ?????)
productPositiveRel ????? ????? .act = productRelAction (????? .act) (????? .act)
productPositiveRel ????? ????? .reflexive (s??? , s???) = ????? .reflexive s??? , ????? .reflexive s???
productPositiveRel ????? ????? .detransitive R R' (rr'??? , rr'???) =
  Trunc.rec squash
    (?? {(s??? , r??? , r???') ???
      Trunc.rec squash
        (?? {(s??? , r??? , r???') ??? ??? (s??? , s???) , (r??? , r???) , (r???' , r???') ???})
        (????? .detransitive R R' rr'???)})
    (????? .detransitive R R' rr'???)
productPositiveRel {S??? = S???} {?????} {?????} {S???} {?????} {?????} ????? ????? .quo {X} R =
  subst isEquiv
    (funExt (elimProp (?? _ ??? productSuitableRel ????? ????? .set squash/ _ _) (?? _ ??? refl)))
    (compEquiv
      (isoToEquiv isom)
      (??-cong-equiv (_ , ????? .quo R) (?? _ ??? _ , ????? .quo R)) .snd)
  where
  fwd :
    ProductStructure S??? S??? X / ProductRelStr ????? ????? (R .fst .fst)
    ??? (S??? X / ????? (R .fst .fst)) ?? (S??? X / ????? (R .fst .fst))
  fwd [ s??? , s??? ] = [ s??? ] , [ s??? ]
  fwd (eq/ (s??? , s???) (t??? , t???) (r??? , r???) i) = eq/ s??? t??? r??? i , eq/ s??? t??? r??? i
  fwd (squash/ _ _ p q i j) =
    isSet?? squash/ squash/ _ _ (cong fwd p) (cong fwd q) i j

  bwd[] : S??? X ??? S??? X / ????? (R .fst .fst)
    ??? ProductStructure S??? S??? X / ProductRelStr ????? ????? (R .fst .fst)
  bwd[] s??? [ s??? ] = [ s??? , s??? ]
  bwd[] s??? (eq/ s??? t??? r??? i) =
    eq/ (s??? , s???) (s??? , t???) (posRelReflexive ????? R s??? , r???) i
  bwd[] s??? (squash/ _ _ p q i j) =
    squash/ _ _ (?? j ??? bwd[] s??? (p j)) (?? j ??? bwd[] s??? (q j)) i j

  bwd : S??? X / ????? (R .fst .fst) ??? S??? X / ????? (R .fst .fst)
    ??? ProductStructure S??? S??? X / ProductRelStr ????? ????? (R .fst .fst)
  bwd [ s??? ] u = bwd[] s??? u
  bwd (eq/ s??? t??? r??? i) u = path u i
    where
    path : ??? u ??? bwd [ s??? ] u ??? bwd [ t??? ] u
    path = elimProp (?? _ ??? squash/ _ _) (?? s??? ??? eq/ (s??? , s???) (t??? , s???) (r??? , posRelReflexive ????? R s???))
  bwd (squash/ _ _ p q i j) =
    isSet?? (?? _ ??? squash/) _ _ (cong bwd p) (cong bwd q) i j

  open Iso
  isom : Iso _ _
  isom .fun = fwd
  isom .inv = uncurry bwd
  isom .rightInv =
    uncurry
      (elimProp (?? _ ??? isProp?? ?? _ ??? isSet?? squash/ squash/ _ _)
        (?? _ ??? elimProp (?? _ ??? isSet?? squash/ squash/ _ _) (?? _ ??? refl)))
  isom .leftInv = elimProp (?? _ ??? squash/ _ _) (?? _ ??? refl)

productRelMatchesTransp :
  {S??? : Type ??? ??? Type ??????} (????? : StrRel S??? ??????') (????? : EquivAction S???)
  {S??? : Type ??? ??? Type ??????} (????? : StrRel S??? ??????') (????? : EquivAction S???)
  ??? StrRelMatchesEquiv ????? (EquivAction???StrEquiv ?????)
  ??? StrRelMatchesEquiv ????? (EquivAction???StrEquiv ?????)
  ??? StrRelMatchesEquiv (ProductRelStr ????? ?????) (EquivAction???StrEquiv (productEquivAction ????? ?????))
productRelMatchesTransp _ _ _ _ ????? ????? _ _ e =
  compEquiv (??-cong-equiv (????? _ _ e) (?? _ ??? ????? _ _ e)) ??Path???Path??
