{-

Macros (autoDesc, AutoStructure, AutoEquivStr, autoUnivalentStr) for automatically generating structure definitions.

For example:

  autoDesc (?? (X : Type???) ??? X ??? X ?? ???)   ???   function+ var (var , constant ???)

We prefer to use the constant structure whenever possible, e.g., [autoDesc (?? (X : Type???) ??? ??? ??? ???)]
is [constant (??? ??? ???)] rather than [function (constant ???) (constant ???)].

Writing [auto* (?? X ??? ???)] doesn't seem to work, but [auto* (?? (X : Type ???) ??? ???)] does.

-}
{-# OPTIONS --cubical --no-exact-split --safe #-}
module Cubical.Algebra.Relational.Auto where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.HLevels
open import Cubical.Data.Sigma
open import Cubical.Data.Nat
open import Cubical.Data.List
open import Cubical.Data.Bool
open import Cubical.Data.Maybe

open import Cubical.Algebra.Relational.Macro as Macro

import Agda.Builtin.Reflection as R

-- Magic number
private
  FUEL = 10000

-- Mark a constant type with a proof it is a set
abstract
  Const[_] : ??? {???} ??? hSet ??? ??? Type ???
  Const[ A ] = A .fst

-- Some reflection utilities
private
  _>>=_ = R.bindTC
  _<|>_ = R.catchTC

  _>>_ : ??? {??? ???'} {A : Type ???} {B : Type ???'} ??? R.TC A ??? R.TC B ??? R.TC B
  f >> g = f >>= ?? _ ??? g

  infixl 4 _>>=_ _>>_ _<|>_

  varg : ??? {???} {A : Type ???} ??? A ??? R.Arg A
  varg = R.arg (R.arg-info R.visible R.relevant)

  tLevel = R.def (quote Level) []

  tType : R.Term ??? R.Term
  tType ??? = R.def (quote Type) [ varg ??? ]

  thSet : R.Term ??? R.Term
  thSet ??? = R.def (quote hSet) [ varg ??? ]

  tPosRelDesc : R.Term ??? R.Term
  tPosRelDesc ??? = R.def (quote PosRelDesc) [ varg ??? ]

  tRelDesc : R.Term ??? R.Term
  tRelDesc ??? = R.def (quote RelDesc) [ varg ??? ]

  func : (??? ???' : Level) ??? Type (???-suc (???-max ??? ???'))
  func ??? ???' = Type ??? ??? Type ???'

  tStruct : R.Term ??? R.Term ??? R.Term
  tStruct ??? ???' = R.def (quote func) (varg ??? ??? varg ???' ??? [])

  newMeta = R.checkType R.unknown

-- We try to build a descriptor by unifying the provided structure with combinators we're aware of. We
-- redefine the structure combinators as the *Shape terms below so that we don't depend on the specific way
-- these are defined in other files (order of implicit arguments and so on); the syntactic analysis that goes
-- on here means that we would get mysterious errors if those changed.
private
  constantShape : ??? {???'} (??? : Level) (A : hSet ???') ??? (Type ??? ??? Type ???')
  constantShape _ A _ = Const[ A ]

  pointedShape : (??? : Level) ??? Type ??? ??? Type ???
  pointedShape _ X = X

  productShape : ??? {?????? ??????} (??? : Level)
    ??? (Type ??? ??? Type ??????) ??? (Type ??? ??? Type ??????) ??? Type ??? ??? Type (???-max ?????? ??????)
  productShape _ A??? A??? X = A??? X ?? A??? X

  paramShape : ??? {?????? ???'} (??? : Level)
    ??? Type ???' ??? (Type ??? ??? Type ??????) ??? Type ??? ??? Type (???-max ???' ??????)
  paramShape _ A A??? X = A ??? A??? X

  functionShape :  ??? {?????? ??????} (??? : Level)
    ??? (Type ??? ??? Type ??????) ??? (Type ??? ??? Type ??????) ??? Type ??? ??? Type (???-max ?????? ??????)
  functionShape _ A??? A??? X = A??? X ??? A??? X

  maybeShape : ??? {??????} (??? : Level)
    ??? (Type ??? ??? Type ??????) ??? Type ??? ??? Type ??????
  maybeShape _ A??? X = Maybe (A??? X)

private
  -- Build transport structure descriptor from a function [t : Type ??? ??? Type ???']
  buildPosRelDesc : ??? ??? R.Term ??? R.Term ??? R.Term ??? R.TC R.Term
  buildPosRelDesc zero ??? ???' t = R.typeError (R.strErr "Ran out of fuel! at \n" ??? R.termErr t ??? [])
  buildPosRelDesc (suc fuel) ??? ???' t =
    tryConstant t <|> tryPointed t <|> tryProduct t <|> tryMaybe t <|>
    R.typeError (R.strErr "Can't automatically generate a positive structure for\n" ??? R.termErr t ??? [])
    where
    tryConstant : R.Term ??? R.TC R.Term
    tryConstant t =
      newMeta (thSet ???') >>= ?? A ???
      R.unify t (R.def (quote constantShape) (varg ??? ??? varg A ??? [])) >>
      R.returnTC (R.con (quote PosRelDesc.constant) (varg A ??? []))

    tryPointed : R.Term ??? R.TC R.Term
    tryPointed t =
      R.unify t (R.def (quote pointedShape) (varg ??? ??? [])) >>
      R.returnTC (R.con (quote PosRelDesc.var) [])

    tryProduct : R.Term ??? R.TC R.Term
    tryProduct t =
      newMeta tLevel >>= ?? ?????? ???
      newMeta tLevel >>= ?? ?????? ???
      newMeta (tStruct ??? ??????) >>= ?? A??? ???
      newMeta (tStruct ??? ??????) >>= ?? A??? ???
      R.unify t (R.def (quote productShape) (varg ??? ??? varg A??? ??? varg A??? ??? [])) >>
      buildPosRelDesc fuel ??? ?????? A??? >>= ?? d??? ???
      buildPosRelDesc fuel ??? ?????? A??? >>= ?? d??? ???
      R.returnTC (R.con (quote PosRelDesc._,_) (varg d??? ??? varg d??? ??? []))

    tryMaybe : R.Term ??? R.TC R.Term
    tryMaybe t =
      newMeta tLevel >>= ?? ?????? ???
      newMeta (tStruct ??? ??????) >>= ?? A??? ???
      R.unify t (R.def (quote maybeShape) (varg ??? ??? varg A??? ??? [])) >>
      buildPosRelDesc fuel ??? ?????? A??? >>= ?? d??? ???
      R.returnTC (R.con (quote PosRelDesc.maybe) (varg d??? ??? []))

  autoPosRelDesc' : R.Term ??? R.Term ??? R.TC Unit
  autoPosRelDesc' t hole =
    R.inferType hole >>= ?? H ???
    newMeta tLevel >>= ?? ??? ???
    newMeta tLevel >>= ?? ???' ???
    R.unify (tPosRelDesc ???) H >>
    R.checkType t (tStruct ??? ???') >>
    buildPosRelDesc FUEL ??? ???' t >>= R.unify hole

  -- Build structure descriptor from a function [t : Type ??? ??? Type ???']
  buildRelDesc : ??? ??? R.Term ??? R.Term ??? R.Term ??? R.TC R.Term
  buildRelDesc zero ??? ???' t = R.typeError (R.strErr "Ran out of fuel! at \n" ??? R.termErr t ??? [])
  buildRelDesc (suc fuel) ??? ???' t =
    tryConstant t <|> tryPointed t <|> tryProduct t <|> tryParam t <|> tryFunction t <|>
    tryMaybe t <|>
    R.typeError (R.strErr "Can't automatically generate a structure for\n" ??? R.termErr t ??? [])
    where
    tryConstant : R.Term ??? R.TC R.Term
    tryConstant t =
      newMeta (thSet ???') >>= ?? A ???
      R.unify t (R.def (quote constantShape) (varg ??? ??? varg A ??? [])) >>
      R.returnTC (R.con (quote RelDesc.constant) (varg A ??? []))

    tryPointed : R.Term ??? R.TC R.Term
    tryPointed t =
      R.unify t (R.def (quote pointedShape) (varg ??? ??? [])) >>
      R.returnTC (R.con (quote RelDesc.var) [])

    tryProduct : R.Term ??? R.TC R.Term
    tryProduct t =
      newMeta tLevel >>= ?? ?????? ???
      newMeta tLevel >>= ?? ?????? ???
      newMeta (tStruct ??? ??????) >>= ?? A??? ???
      newMeta (tStruct ??? ??????) >>= ?? A??? ???
      R.unify t (R.def (quote productShape) (varg ??? ??? varg A??? ??? varg A??? ??? [])) >>
      buildRelDesc fuel ??? ?????? A??? >>= ?? d??? ???
      buildRelDesc fuel ??? ?????? A??? >>= ?? d??? ???
      R.returnTC (R.con (quote RelDesc._,_) (varg d??? ??? varg d??? ??? []))

    tryParam : R.Term ??? R.TC R.Term
    tryParam t =
      newMeta (tType R.unknown) >>= ?? A ???
      newMeta tLevel >>= ?? ?????? ???
      newMeta (tStruct ??? ??????) >>= ?? A??? ???
      R.unify t (R.def (quote paramShape) (varg ??? ??? varg A ??? varg A??? ??? [])) >>
      buildRelDesc fuel ??? ?????? A??? >>= ?? d??? ???
      R.returnTC (R.con (quote RelDesc.param) (varg A ??? varg d??? ??? []))

    tryFunction : R.Term ??? R.TC R.Term
    tryFunction t =
      newMeta tLevel >>= ?? ?????? ???
      newMeta tLevel >>= ?? ?????? ???
      newMeta (tStruct ??? ??????) >>= ?? A??? ???
      newMeta (tStruct ??? ??????) >>= ?? A??? ???
      R.unify t (R.def (quote functionShape) (varg ??? ??? varg A??? ??? varg A??? ??? [])) >>
      buildPosRelDesc fuel ??? ?????? A??? >>= ?? d??? ???
      buildRelDesc fuel ??? ?????? A??? >>= ?? d??? ???
      R.returnTC (R.con (quote RelDesc.function+) (varg d??? ??? varg d??? ??? []))

    tryMaybe : R.Term ??? R.TC R.Term
    tryMaybe t =
      newMeta tLevel >>= ?? ?????? ???
      newMeta (tStruct ??? ??????) >>= ?? A??? ???
      R.unify t (R.def (quote maybeShape) (varg ??? ??? varg A??? ??? [])) >>
      buildRelDesc fuel ??? ?????? A??? >>= ?? d??? ???
      R.returnTC (R.con (quote RelDesc.maybe) (varg d??? ??? []))

  autoRelDesc' : R.Term ??? R.Term ??? R.TC Unit
  autoRelDesc' t hole =
    R.inferType hole >>= ?? H ???
    newMeta tLevel >>= ?? ??? ???
    newMeta tLevel >>= ?? ???' ???
    R.unify (tRelDesc ???) H >>
    R.checkType t (tStruct ??? ???') >>
    buildRelDesc FUEL ??? ???' t >>= R.unify hole

macro
  -- (Type ??? ??? Type ??????) ??? PosRelDesc ???
  autoPosRelDesc : R.Term ??? R.Term ??? R.TC Unit
  autoPosRelDesc = autoPosRelDesc'

  -- (S : Type ??? ??? Type ??????) ??? RelDesc ???
  autoRelDesc : R.Term ??? R.Term ??? R.TC Unit
  autoRelDesc = autoRelDesc'

  -- (S : Type ??? ??? Type ??????) ??? (Type ??? ??? Type ??????)
  -- Sanity check: should be the identity
  AutoStructure : R.Term ??? R.Term ??? R.TC Unit
  AutoStructure t hole =
    newMeta (tRelDesc R.unknown) >>= ?? d ???
    R.unify hole (R.def (quote RelMacroStructure) [ varg d ]) >>
    autoRelDesc' t d

  -- (S : Type ??? ??? Type ??????) ??? StrRel S _
  AutoRelStr : R.Term ??? R.Term ??? R.TC Unit
  AutoRelStr t hole =
    newMeta (tRelDesc R.unknown) >>= ?? d ???
    R.unify hole (R.def (quote RelMacroRelStr) [ varg d ]) >>
    autoRelDesc' t d

  -- (S : Type ??? ??? Type ??????) ??? SuitableStrRel S (AutoStrRel S)
  autoSuitableRel : R.Term ??? R.Term ??? R.TC Unit
  autoSuitableRel t hole =
    newMeta (tRelDesc R.unknown) >>= ?? d ???
    R.unify hole (R.def (quote relMacroSuitableRel) [ varg d ]) >>
    autoRelDesc' t d

  -- (S : Type ??? ??? Type ??????) ??? StrRelMatchesEquiv (AutoRelStr S) (AutoEquivStr S)
  autoMatchesEquiv : R.Term ??? R.Term ??? R.TC Unit
  autoMatchesEquiv t hole =
    newMeta (tRelDesc R.unknown) >>= ?? d ???
    R.unify hole (R.def (quote relMacroMatchesEquiv) [ varg d ]) >>
    autoRelDesc' t d
