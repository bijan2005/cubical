{-

Index a structure T a positive structure S: X ??? S X ??? T X

-}
{-# OPTIONS --cubical --no-import-sorts --safe #-}
module Cubical.Algebra.Relational.Function where

open import Cubical.Foundations.Prelude
open import Cubical.Foundations.Isomorphism
open import Cubical.Foundations.Equiv
open import Cubical.Foundations.Function
open import Cubical.Foundations.HLevels
open import Cubical.Foundations.Structure
open import Cubical.Foundations.RelationalStructure
open import Cubical.Foundations.Univalence
open import Cubical.Functions.FunExtEquiv
open import Cubical.Data.Sigma
open import Cubical.Relation.Binary.Base
open import Cubical.Relation.ZigZag.Base
open import Cubical.HITs.SetQuotients
open import Cubical.HITs.PropositionalTruncation as Trunc

open import Cubical.Algebra.Function

private
  variable
    ??? ?????? ??????' ??????'' ?????? ??????' ??????'' : Level

FunctionRelStr : {S : Type ??? ??? Type ??????} {T : Type ??? ??? Type ??????}
  ??? StrRel S ??????' ??? StrRel T ??????' ??? StrRel (FunctionStructure S T) (???-max ?????? (???-max ??????' ??????'))
FunctionRelStr ????? ????? R f g =
  ??? {x y} ??? ????? R x y ??? ????? R (f x) (g y)

open BinaryRelation
open isEquivRel

private
  composeWith[_] : {A : Type ???} (R : EquivPropRel A ???)
    ??? compPropRel (R .fst) (quotientPropRel (R .fst .fst)) .fst ??? graphRel [_]
  composeWith[_] R =
    funExt??? ?? a t ???
    hPropExt squash (squash/ _ _)
      (Trunc.rec (squash/ _ _) (?? {(b , r , p) ??? eq/ a b r ??? p }))
      (?? p ??? ??? a , R .snd .reflexive a , p ???)

  [_]???[_]????? : {A : Type ???} (R : EquivPropRel A ???)
    ??? compPropRel (quotientPropRel (R .fst .fst)) (invPropRel (quotientPropRel (R .fst .fst))) .fst
      ??? R .fst .fst
  [_]???[_]????? R =
    funExt??? ?? a b ???
    hPropExt squash (R .fst .snd a b)
      (Trunc.rec (R .fst .snd a b)
        (?? {(c , p , q) ??? effective (R .fst .snd) (R .snd) a b (p ??? sym q)}))
      (?? r ??? ??? _ , eq/ a b r , refl ???)

functionSuitableRel : {S : Type ??? ??? Type ??????} {T : Type ??? ??? Type ??????}
  {????? : StrRel S ??????'} {????? : StrRel T ??????'}
  (????? : SuitableStrRel S ?????)
  ??? PositiveStrRel ?????
  ??? SuitableStrRel T ?????
  ??? SuitableStrRel (FunctionStructure S T) (FunctionRelStr ????? ?????)
functionSuitableRel {S = S} {T = T} {????? = ?????} {?????} ????? ????? ????? .quo (X , f) R h =
  final
  where
  ref : (s : S X) ??? ????? (R .fst .fst) s s
  ref = posRelReflexive ????? R

  [f] : S X / ????? (R .fst .fst) ??? T (X / R .fst .fst)
  [f] [ s ] = ????? .quo (X , f s) R (h (ref s)) .fst .fst
  [f] (eq/ s??? s??? r i) =
    cong fst
      (????? .quo (X , f s???) R (h (ref s???)) .snd
        ( [f] [ s??? ]
        , subst (?? R' ??? ????? R' (f s???) ([f] [ s??? ]))
          (composeWith[_] R)
          (????? .transitive (R .fst) (quotientPropRel (R .fst .fst))
            (h r)
            (????? .quo (X , f s???) R (h (ref s???)) .fst .snd))
        ))
      i
  [f] (squash/ _ _ p q j i) =
    ????? .set squash/ _ _ (cong [f] p) (cong [f] q) j i

  relLemma : (s : S X) (t : S X)
    ??? ????? (graphRel [_]) s (funIsEq (????? .quo R) [ t ])
    ??? ????? (graphRel [_]) (f s) ([f] [ t ])
  relLemma s t r =
    subst (?? R' ??? ????? R' (f s) ([f] [ t ]))
      (composeWith[_] R)
      (????? .transitive (R .fst) (quotientPropRel (R .fst .fst))
        (h r')
        (????? .quo (X , f t) R (h (ref t)) .fst .snd))
    where
    r' : ????? (R .fst .fst) s t
    r' =
      subst (?? R' ??? ????? R' s t) ([_]???[_]????? R)
        (????? .transitive
          (quotientPropRel (R .fst .fst))
          (invPropRel (quotientPropRel (R .fst .fst)))
          r
          (????? .symmetric (quotientPropRel (R .fst .fst))
            (subst
              (?? t' ??? ????? (graphRel [_]) t' (funIsEq (????? .quo R) [ t ]))
              (????? .act .actStrId t)
              (????? .act .actRel eq/ t t (ref t)))))

  quoRelLemma : (s : S X) (t : S X / ????? (R .fst .fst))
    ??? ????? (graphRel [_]) s (funIsEq (????? .quo R) t)
    ??? ????? (graphRel [_]) (f s) ([f] t)
  quoRelLemma s =
    elimProp (?? _ ??? isProp?? ?? _ ??? ????? .prop (?? _ _ ??? squash/ _ _) _ _)
      (relLemma s)

  final : ?? (?? _ _) _
  final .fst .fst = [f] ??? invIsEq (????? .quo R)
  final .fst .snd {s} {t} r =
    quoRelLemma s
      (invIsEq (????? .quo R) t)
      (subst (????? (graphRel [_]) s) (sym (secIsEq (????? .quo R) t)) r)
  final .snd (f' , c) =
    ?????Prop
      (?? _ ??? isPropImplicit?? ?? s ???
        isPropImplicit?? ?? t ???
        isProp?? ?? _ ??? ????? .prop (?? _ _ ??? squash/ _ _) _ _)
      (funExt ?? s ??? contractorLemma (invIsEq (????? .quo R) s) ??? cong f' (secIsEq (????? .quo R) s))
    where
    contractorLemma : (s : S X / ????? (R .fst .fst))
      ??? [f] s ??? f' (funIsEq (????? .quo R) s)
    contractorLemma =
      elimProp
        (?? _ ??? ????? .set squash/ _ _)
        (?? s ???
          cong fst
            (????? .quo (X , f s) R (h (ref s)) .snd
              ( f' (funIsEq (????? .quo R) [ s ])
              , c
                (subst
                  (?? s' ??? ????? (graphRel [_]) s' (funIsEq (????? .quo R) [ s ]))
                  (????? .act .actStrId s)
                  (????? .act .actRel eq/ s s (ref s)))
              )))
functionSuitableRel {????? = ?????} {?????} ????? ?? ????? .symmetric R h r =
  ????? .symmetric R (h (????? .symmetric (invPropRel R) r))
functionSuitableRel {????? = ?????} {?????} ????? ?? ????? .transitive R R' h h' rr' =
  Trunc.rec
    (????? .prop (?? _ _ ??? squash) _ _)
    (?? {(_ , r , r') ??? ????? .transitive R R' (h r) (h' r')})
    (?? .detransitive R R' rr')
functionSuitableRel {????? = ?????} {?????} ????? ?? ????? .set setX =
  isSet?? ?? _ ??? ????? .set setX
functionSuitableRel {????? = ?????} {?????} ????? ?? ????? .prop propR f g =
  isPropImplicit?? ?? _ ???
  isPropImplicit?? ?? _ ???
  isProp?? ?? _ ???
  ????? .prop propR _ _

functionRelMatchesEquiv : {S : Type ??? ??? Type ??????} {T : Type ??? ??? Type ??????}
  (????? : StrRel S ??????') {????? : StrEquiv S ??????''}
  (????? : StrRel T ??????') {????? : StrEquiv T ??????''}
  ??? StrRelMatchesEquiv ????? ?????
  ??? StrRelMatchesEquiv ????? ?????
  ??? StrRelMatchesEquiv (FunctionRelStr ????? ?????) (FunctionEquivStr ????? ?????)
functionRelMatchesEquiv ????? ????? ????? ????? (X , f) (Y , g) e =
  equivImplicit??Cod (equivImplicit??Cod (equiv??? (????? _ _ e) (????? _ _ e)))

functionRelMatchesEquiv+ : {S : Type ??? ??? Type ??????} {T : Type ??? ??? Type ??????}
  (????? : StrRel S ??????') (????? : EquivAction S)
  (????? : StrRel T ??????') (????? : StrEquiv T ??????'')
  ??? StrRelMatchesEquiv ????? (EquivAction???StrEquiv ?????)
  ??? StrRelMatchesEquiv ????? ?????
  ??? StrRelMatchesEquiv (FunctionRelStr ????? ?????) (FunctionEquivStr+ ????? ?????)
functionRelMatchesEquiv+ ????? ????? ????? ????? ????? ????? (X , f) (Y , g) e =
  compEquiv
    (functionRelMatchesEquiv ????? ????? ????? ????? (X , f) (Y , g) e)
    (isoToEquiv isom)
  where
  open Iso
  isom : Iso
    (FunctionEquivStr (EquivAction???StrEquiv ?????) ????? (X , f) (Y , g) e)
    (FunctionEquivStr+ ????? ????? (X , f) (Y , g) e)
  isom .fun h s = h refl
  isom .inv k {x} = J (?? y _ ??? ????? (X , f x) (Y , g y) e) (k x)
  isom .rightInv k i x = JRefl (?? y _ ??? ????? (X , f x) (Y , g y) e) (k x) i
  isom .leftInv h =
    implicitFunExt ?? {x} ???
    implicitFunExt ?? {y} ???
    funExt ?? p ???
    J (?? y p ??? isom .inv (isom .fun h) p ??? h p)
      (funExt??? (isom .rightInv (isom .fun h)) x)
      p
